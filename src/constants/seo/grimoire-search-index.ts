/**
 * Grimoire Search Index
 * Data auto-generated by scripts/build-grimoire-search-index.ts
 * Do not edit grimoire-search-index.json manually.
 */

import grimoireSearchIndexData from './grimoire-search-index.json';

export interface GrimoireEntry {
  slug: string;
  title: string;
  category:
    | 'zodiac'
    | 'planet'
    | 'tarot'
    | 'crystal'
    | 'ritual'
    | 'concept'
    | 'horoscope'
    | 'chinese-zodiac'
    | 'season'
    | 'numerology'
    | 'birthday'
    | 'compatibility'
    | 'glossary'
    | 'archetype';
  keywords: string[];
  summary: string;
  relatedSlugs: string[];
}

export const GRIMOIRE_SEARCH_INDEX: GrimoireEntry[] =
  grimoireSearchIndexData as GrimoireEntry[];

/**
 * Search the grimoire index
 * Returns entries matching the query, sorted by relevance
 */
export function searchGrimoireIndex(
  query: string,
  limit = 10,
): GrimoireEntry[] {
  const queryLower = query.toLowerCase().trim();
  const queryWords = queryLower.split(/\s+/).filter((w) => w.length > 2);

  if (queryWords.length === 0) return [];

  // Score each entry
  const scored = GRIMOIRE_SEARCH_INDEX.map((entry) => {
    let score = 0;

    // Title match (highest weight)
    if (entry.title.toLowerCase().includes(queryLower)) {
      score += 100;
    }

    // Exact keyword match
    for (const keyword of entry.keywords) {
      if (keyword === queryLower) {
        score += 50;
      } else if (keyword.includes(queryLower)) {
        score += 25;
      }
    }

    // Word-by-word matching
    for (const word of queryWords) {
      // Title word match
      if (entry.title.toLowerCase().includes(word)) {
        score += 10;
      }

      // Keyword word match
      for (const keyword of entry.keywords) {
        if (keyword.includes(word)) {
          score += 5;
        }
      }

      // Summary word match
      if (entry.summary.toLowerCase().includes(word)) {
        score += 2;
      }
    }

    return { entry, score };
  });

  // Filter and sort by score
  return scored
    .filter((s) => s.score > 0)
    .sort((a, b) => b.score - a.score)
    .slice(0, limit)
    .map((s) => s.entry);
}

/**
 * Get related entries for a given slug
 */
export function getRelatedEntries(slug: string): GrimoireEntry[] {
  const entry = GRIMOIRE_SEARCH_INDEX.find((e) => e.slug === slug);
  if (!entry) return [];

  return entry.relatedSlugs
    .map((relatedSlug) =>
      GRIMOIRE_SEARCH_INDEX.find((e) => e.slug === relatedSlug),
    )
    .filter((e): e is GrimoireEntry => e !== undefined);
}
